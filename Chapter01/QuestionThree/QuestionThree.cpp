#include <stdio.h>

#define BITSPERWORD 32	// 假设当前机器int类型占用 32 bit
#define SHIFT 5	// 32 = 2^5		 32是2的5次方
#define MASK 0x1F	// 转换为二进制：11111
#define N 10000000	// 元素个数

int a[1 + N / BITSPERWORD];	// 用int类型数组存储所有元素，每个bit存储表示一个元素

/**
 * 32 = 2^5 => 转换为二进制就是1前面5个0，因为二进制是从2^0开始 => 100000
 * 32/32 = 1 => 32与32相除等于1，从二进制角度看，等于右移5位 => 000001
 *
 * 由上可知，如果一个数的二进制数前5位都是0，那么这个数一定是32的倍数，能被32整除，而且整除的结果为二进制右移5位后的结果
 * 同样，如果一个数不能被32整除，那么这个数的二进制数前5位一定不都是0，而且，二进制数的前5位为这个数与32相除后的余数，二进制数右移5位的结果为这个数与32相除后的商
 *
 * 对乘法而言，1*32 = 32 => 1与32相乘等于32，从二进制角度看，等于左移5位，即在左边加5个0 => 000001 -> 100000
 *
 * 总结：对于位运算，一个二进制数左移等于乘以2的倍数，右移等于除以2的倍数。左移n位等于乘以2的n次方，右移n位等于除以2的n次方。其中，对于右移操作，二进制数右移前的前n位为除后的余数，右移后的结果为除后的商。
 */


/**
 * i 表示需要进行操作的第 i 个对象
 * i >> SHIFT 相当于 i/32，将 i 定位到具体的数组中
 * i & MASK 相当于 i % 32，取 i 的二进制前五位，即除以32后的余数，在本次32位int类型的对象中处于第几位，将1左移余数位指从32位二进制位的顺序上将对应位置的比特位设为1（余数不可能为32，因此余数是0~31）
 */


/**
 * a[i >> SHIFT] 的值的二进制数初始情况下为0，（i << (i&MASK)）将对应位的二进制值设置位1，与 a[i >> SHIFT] 进行 '|' 或操作后，（i << (i&MASK)）将对应位的二进制值得以保留。
 */
// 设置比特位
void setBit(int i)
{
	a[i >> SHIFT] |= (1 << (i&MASK));
}

/**
 * （i << (i&MASK)）将对应位的二进制值设置位1，取反后对应位为0，其他位为1。与 a[i >> SHIFT] 进行 '&' 与操作后，将清除（i << (i&MASK)）对应位，即将二进制值修改为0。
 */
// 清除比特位
void clearBit(int i)
{
	a[i >> SHIFT] &= ~(1 << (i&MASK));
}

/**
 * （i << (i&MASK)）将对应位的二进制值设置位1，取反后对应位为0，其他位为1。与 a[i >> SHIFT] 进行 '&' 与操作后，将清除（i << (i&MASK)）对应位，即将二进制值修改为0。
 */
// 判断该元素是否存入数组
int testBit(int i)
{
	return a[i >> SHIFT] & (1 << (i&MASK));
}